<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ハノイの塔 (JavaScript)</title>
    <style>
        body {
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column; 
            justify-content: center;
            align-items: center;
            margin: 0;
            padding-top: 10px; 
            font-family: 'Yu Gothic', 'Hiragino Kaku Gothic ProN', Meiryo, sans-serif;
            height: 100vh;
            overflow: hidden;
        }
        #controls {
            margin-bottom: 10px;
        }
        #controls label {
            font-size: 20px; /* ★★★ 5ボタン入るよう少し縮小 ★★★ */
            margin-right: 5px;
            vertical-align: middle;
        }
        #controls button {
            padding: 6px 10px; /* ★★★ 5ボタン入るよう少し縮小 ★★★ */
            font-size: 18px;   /* ★★★ 5ボタン入るよう少し縮小 ★★★ */
            cursor: pointer;
            margin-left: 3px;
            border: 1px solid #ccc;
            background-color: #fff;
            border-radius: 4px;
        }
        #controls button:hover {
            background-color: #f5f5f5;
        }
        canvas {
            background-color: #FAF8EF;
            border: 1px solid #ccc;
            max-width: 100%;
            height: auto; 
        }
    </style>
</head>
<body>

<div id="controls">
    <label>円盤の枚数:</label>
    <button id="btn3">3枚</button>
    <button id="btn5">5枚</button>
    <button id="btn10">10枚</button>
    <button id="btn14">14枚</button>
    <button id="btn21">21枚</button>
</div>

<canvas id="gameCanvas" width="500" height="600"></canvas>

<script>
    // --- 定数 ---
    const SCREEN_WIDTH = 500;
    const SCREEN_HEIGHT = 600;

    const COLOR_PEG = "#8B4513";
    const COLOR_DISK_OUTLINE = "#000000";
    const COLOR_TEXT = "#000000";
    const COLOR_HIGHLIGHT = "#FFC107";
    const COLOR_WIN_BG = "rgba(245, 245, 245, 0.8)";

    // ★★★ 円盤の色 (虹色7色 x 3段 = 21色) ★★★
    const RAINBOW_COLORS = [
        "#FF0000", // 赤
        "#FFA500", // 橙
        "#FFFF00", // 黄
        "#008000", // 緑
        "#0000FF", // 青
        "#4B0082", // 藍 (Indigo)
        "#8A2BE2"  // 紫 (Violet)
    ];
    // 虹色を3回繰り返す
    const DISK_COLORS = [...RAINBOW_COLORS, ...RAINBOW_COLORS, ...RAINBOW_COLORS];

    // --- ★★★ レイアウト調整 (21段に対応) ★★★ ---
    const DISK_HEIGHT = 14;     // (旧 20) 21枚積んでもOKな高さ
    const MIN_DISK_WIDTH = 20;  // (旧 30)
    const DISK_WIDTH_STEP = 6;  // (旧 8) 21段でも画面幅に収まるように

    const PEG_WIDTH = 15;
    const PEG_HEIGHT = 300;     
    const PEG_Y_BOTTOM = 500;   
    
    // ★★★ 杭のX座標を21段の幅に合わせて再配置 ★★★
    const PEG_X_CENTERS = [85, 250, 415]; // (旧 [125, 250, 375])
    
    const BASE_HEIGHT = 20;

    class HanoiGame {
        constructor(canvasId, initialDisks) {
            this.canvas = document.getElementById(canvasId);
            this.ctx = this.canvas.getContext('2d');
            
            this.numDisks = initialDisks;
            this.optimalMoves = (2 ** this.numDisks) - 1;

            this.fontLarge = "60px 'Yu Gothic', 'Hiragino Kaku Gothic ProN', Meiryo, sans-serif";
            this.fontMedium = "30px 'Yu Gothic', 'Hiragino Kaku Gothic ProN', Meiryo, sans-serif";
            
            this.setup();
            this.initEvents();
            this.run();
        }

        changeDisks(newNumDisks) {
            if (newNumDisks > DISK_COLORS.length) {
                alert(`色の定義が足りません。最大 ${DISK_COLORS.length} 枚までです。`);
                return;
            }
            this.numDisks = newNumDisks;
            this.optimalMoves = (2 ** newNumDisks) - 1;
            this.setup();
        }

        setup() {
            this.pegs = [[], [], []];
            this.pegs[0] = Array.from({ length: this.numDisks }, (_, i) => this.numDisks - i);
            
            this.selectedPeg = null;
            this.moveCount = 0;
            this.isWin = false;
            this.startTime = performance.now();
            this.totalTime = 0;
        }

        initEvents() {
            this.canvas.addEventListener('click', (event) => {
                const rect = this.canvas.getBoundingClientRect();
                const clientX = event.clientX || (event.touches && event.touches[0].clientX);
                if (clientX === undefined) return;
                
                const x = clientX - rect.left;
                
                const scale = this.canvas.width / rect.width;
                this.handleClick(x * scale);
            });

            document.addEventListener('keydown', (event) => {
                if (event.key === 'r' || event.key === 'R') {
                    this.setup();
                }
            });
        }

        getPegAtX(x) {
            // ★★★ クリック範囲を杭の間隔で計算 ★★★
            const clickMargin = (PEG_X_CENTERS[1] - PEG_X_CENTERS[0]) / 2; // (250-85)/2 = 82.5
            for (let i = 0; i < PEG_X_CENTERS.length; i++) {
                if (Math.abs(x - PEG_X_CENTERS[i]) < clickMargin) {
                    return i;
                }
            }
            return -1;
        }

        handleClick(x) {
            if (this.isWin) {
                this.setup();
                return;
            }
            const clickedPegIdx = this.getPegAtX(x);
            if (clickedPegIdx === -1) {
                this.selectedPeg = null;
                return;
            }
            if (this.selectedPeg === null) {
                if (this.pegs[clickedPegIdx].length > 0) {
                    this.selectedPeg = clickedPegIdx;
                }
            } else {
                this.moveDisk(this.selectedPeg, clickedPegIdx);
                this.selectedPeg = null; 
            }
        }

        moveDisk(fromIdx, toIdx) {
            if (fromIdx === toIdx) return;
            const fromStack = this.pegs[fromIdx];
            const toStack = this.pegs[toIdx];
            if (fromStack.length === 0) return; 
            const diskToMove = fromStack[fromStack.length - 1]; 
            if (toStack.length === 0 || diskToMove < toStack[toStack.length - 1]) {
                const disk = fromStack.pop();
                toStack.push(disk);
                this.moveCount++;
                this.checkWin();
            }
        }

        checkWin() {
            if (this.pegs[1].length === this.numDisks || this.pegs[2].length === this.numDisks) {
                this.isWin = true;
                this.totalTime = (performance.now() - this.startTime) / 1000;
            }
        }

        run() {
            this.draw();
            requestAnimationFrame(() => this.run());
        }

        drawText(text, x, y, font, color, align = "center") {
            this.ctx.fillStyle = color;
            this.ctx.font = font;
            this.ctx.textAlign = align;
            this.ctx.textBaseline = "middle";
            this.ctx.fillText(text, x, y);
        }

        draw() {
            this.ctx.clearRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

            // --- 杭の描画 (土台の幅を調整) ---
            this.ctx.fillStyle = COLOR_PEG;
            PEG_X_CENTERS.forEach(x_center => {
                // ★★★ 21段の最大幅に合わせて土台の幅を計算 ★★★
                const maxDiskWidth = MIN_DISK_WIDTH + (21 - 1) * DISK_WIDTH_STEP; // 20 + 20*6 = 140
                const baseWidth = maxDiskWidth + 20; // 160 (杭の間隔 165 に収まる)
                
                const baseLeft = x_center - baseWidth / 2;
                const baseTop = PEG_Y_BOTTOM - BASE_HEIGHT;
                this.ctx.fillRect(baseLeft, baseTop, baseWidth, BASE_HEIGHT);
                
                const pegLeft = x_center - PEG_WIDTH / 2;
                const pegTop = PEG_Y_BOTTOM - BASE_HEIGHT - PEG_HEIGHT;
                this.ctx.fillRect(pegLeft, pegTop, PEG_WIDTH, PEG_HEIGHT);
            });

            // --- 選択中ハイライトの描画 ---
            if (this.selectedPeg !== null) {
                const x_center = PEG_X_CENTERS[this.selectedPeg];
                const hlWidth = PEG_WIDTH + 15;
                const hlHeight = PEG_HEIGHT + 15;
                const hlLeft = x_center - hlWidth / 2;
                const hlTop = PEG_Y_BOTTOM - BASE_HEIGHT - PEG_HEIGHT - (hlHeight - PEG_HEIGHT) / 2;
                
                this.ctx.strokeStyle = COLOR_HIGHLIGHT;
                this.ctx.lineWidth = 5;
                this.ctx.strokeRect(hlLeft, hlTop, hlWidth, hlHeight);
            }

            // --- 円盤の描画 ---
            this.pegs.forEach((stack, pegIdx) => {
                const peg_x_center = PEG_X_CENTERS[pegIdx];
                
                stack.forEach((diskSize, diskIdx) => {
                    const diskWidth = MIN_DISK_WIDTH + (diskSize - 1) * DISK_WIDTH_STEP;
                    const diskLeft = peg_x_center - diskWidth / 2;
                    const diskTop = PEG_Y_BOTTOM - BASE_HEIGHT - (diskIdx * DISK_HEIGHT) - DISK_HEIGHT;
                    
                    // ★★★ 色を虹色x3でループさせる ★★★
                    const colorIndex = (diskSize - 1) % DISK_COLORS.length;
                    const color = DISK_COLORS[colorIndex];
                    
                    this.ctx.fillStyle = color;
                    this.ctx.fillRect(diskLeft, diskTop, diskWidth, DISK_HEIGHT);
                    
                    this.ctx.strokeStyle = COLOR_DISK_OUTLINE;
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeRect(diskLeft, diskTop, diskWidth, DISK_HEIGHT);
                });
            });

            // --- クリアメッセージの描画 ---
            if (this.isWin) {
                const boxWidth = 450;
                const boxHeight = 250;
                
                const gameAreaTop = PEG_Y_BOTTOM - BASE_HEIGHT - PEG_HEIGHT; 
                const gameAreaCenterY = gameAreaTop + (PEG_HEIGHT / 2);
                const boxLeft = (SCREEN_WIDTH / 2) - boxWidth / 2;
                const boxTop = gameAreaCenterY - (boxHeight / 2);
                
                this.ctx.fillStyle = COLOR_WIN_BG;
                this.ctx.fillRect(boxLeft, boxTop, boxWidth, boxHeight);
                
                this.drawText("CLEAR!", SCREEN_WIDTH / 2, boxTop + 60, this.fontLarge, COLOR_TEXT);
                
                const timeStr = `${this.totalTime.toFixed(2)} 秒`;
                this.drawText(`タイム: ${timeStr}`, SCREEN_WIDTH / 2, boxTop + 130, this.fontMedium, COLOR_TEXT);

                const resultText = `移動回数: ${this.moveCount} (最短: ${this.optimalMoves})`;
                this.drawText(resultText, SCREEN_WIDTH / 2, boxTop + 180, this.fontMedium, COLOR_TEXT);
            }
        }
    }

    // デフォルトは3枚で開始
    const game = new HanoiGame('gameCanvas', 3);

    // ★★★ 5つのボタンすべてのイベントリスナーを接続 ★★★
    document.getElementById('btn3').addEventListener('click', () => {
        game.changeDisks(3);
    });
    document.getElementById('btn5').addEventListener('click', () => {
        game.changeDisks(5);
    });
    document.getElementById('btn10').addEventListener('click', () => {
        game.changeDisks(10);
    });
    document.getElementById('btn14').addEventListener('click', () => {
        game.changeDisks(14);
    });
    document.getElementById('btn21').addEventListener('click', () => {
        game.changeDisks(21);
    });

</script>

</body>
</html>
